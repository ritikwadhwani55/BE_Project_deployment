# -*- coding: utf-8 -*-
"""BE - road route

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1__0LvetHENuGSbq0H4Y8VgH7S59fZuO8
"""

# Commented out IPython magic to ensure Python compatibility.
# %mkdir templates -p

# text = '''
# plotly
# osmnx==1.1.1
# matplotlib==3.3
# networkx
# numpy
# pandas
# geopy
# geopandas
# scipy
# pykalman
# datetime
# IPython
# display
# gtts
# gmplot
# flask
# flask-ngrok
# folium
# Jinja2
# gunicorn
# opencage
# requests
# bs4
# '''
# file=open('requirements.txt','w')
# file.write(text)
# file.close()

# !pip install -r requirements.txt



# text='''
#       <!DOCTYPE html>
# <html lang="en">
# <head>
#     <meta charset="UTF-8">
#     <meta http-equiv="X-UA-Compatible" content="IE=edge">
#     <meta name="viewport" content="width=device-width, initial-scale=1.0">
#     <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
#         <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
#         <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.min.js" integrity="sha384-cn7l7gDp0eyniUwwAZgrzD06kc/tftFf19TOAs2zVinnD/C7E91j9yyk5//jjpt/" crossorigin="anonymous"></script>
#     <title></title>
#     <style>
#         .loader {
#                 width: 100%;
#                 height: 100%;
#                 color: green;
#                 background-color:blue;
#                 position: absolute;
#                 top: 0%;
#                 left: 0%;
#                 display: flex;
#                 justify-content: center;
#                 align-items: center;
#             }
#             .loader i {
# /*                 
#                 width: 200px;
#                 height: 200px; */
#                 position: relative;
#                 font-size: 30px;
#             }
#             .loader li {
#                 list-style: none;
#                 font-size: 1.4rem;
#             }
#     </style>
# </head>
# <body>
#     <div class="loader">
#         <li><i class="fa-li fa fa-spinner fa-spin"></i>Please wait until the Optimized route is generated!</li>
#         <!-- <i class="fas fa-angle-double-right"></i> -->
#     </div>
# </body>
# </html>

# '''
# file=open('templates/loader.html','w')
# file.write(text)
# file.close()

# text='''
# <!DOCTYPE hTmL>
# <html>
#     <head>
#         <style>
#             * {
#                 margin: 0;
#                 padding: 0;
#             }
#             body{
#               background-image:url("https://image.shutterstock.com/image-photo/beautiful-view-scenic-road-alaska-260nw-1812650770.jpg");
#               background-repeat:no-repeat;
#               background-size:cover;
#             }
#             div.details {
#               background-color: purple;
#               color:white;
#               text-align:center;
#               width: 82%;
#               margin: auto;
#               border-radius: 10px;
#               /* display: flex; */
#             }
          
#             form {
#                 display: flex;
#                 flex-direction: column;
#                 width: 80%;
#                 border: 3px solid grey;
#                 /* border: 2px solid yellowgreen; */
#                 border-radius: 21px;
#                 justify-content: center;
#                 /* padding: 3%; */
#                 margin: auto;
#                 align-items: center;
#                 height:365px;
#                 /* display: none; */
#                 position: relative;
               
#                 background-color:#e1ecfc;
#                 animation-name: display;
#                 animation-duration: 1s;
#                 animation-timing-function: ease-in;
#                 /* transform: skew(360deg); */
                
#             }
#             .map {
#               width: 100%;
#               margin: 1%;
#               height: 450px;

#             }
#             @keyframes display {
#                 0% {
#                     transform: scale(0);
#                 }
                
#                 50% {
#                     transform: scale(1);
#                 }
#             }

#             form div {
#                 display: flex;
#                 flex-direction: column;
                
#                 align-items: center;
#                 /* margin: auto 10%; */
#                 width: 100%;
#                 height: 100%;
#                 justify-content: space-around;
                
#                 /* margin-left: 30%; */
#             }
#             form div>input {
#                 border-radius: 5px;
#                 padding: 2px;
#             }
#             form div>label {
#                 color: black;
#                 font-size: 1.2rem;
#                 font-weight: bold;
#             }
#             form div>input {
#                 width: 60%;
#             }
#             form input[type=submit] {
#                 /* width: 35%; */
#                 background-color: #55d4c9;
#                 padding: 5px;
#                 border-radius: 10px;
#                 font-size: 1.2rem;
#                 font-weight: bold;
#                 margin-top:30px;
#                 margin-bottom:20px;

#             }
#             .loader {
#                 width: 100%;
#                 height: 100%;
#                 color: yellow;
#                 position: absolute;
#                 top: 0%;
#                 left: 0%;
#                 display: flex;
#                 justify-content: center;
#                 align-items: center;
#                 background-color:blue;
                
                
#             }
#             .loader div {
#                 display:inline;
#                 position: relative;
#                 font-size: 38px;
               
#             }

#             div.ok {
#               display:none;
#             }
#             .loader li,.ok li {
#                 list-style: none;
#                 font-size: 3.2rem;
#                 padding: 0px;
#                 /* border: 1px solid red; */
#                 text-align: center;
#                 display:none;
#             } 
#             li .spinner-border {
#               display: none;
#               margin: auto;
#             }
#             .GFG{
#               background-color:#55d4c9;
#               border:2px solid black;
#               color:black;
#               padding:5px 10px;
#               text-align:center;
#               font-size:20px;
#               display:block;
#               margin: auto;
#               cursor:pointer;
#               /* margin-left:660px;
#               margin-top:44px; */
#             }

#             nav.navbar {
#                 width: 100%;
                
#             }
#             a {
#                 display: block;
#                 margin: auto;
#             }

#             .autocomplete-container1 {
#   /*the container must be positioned relative:*/
#   position: relative;
  
#   margin-bottom: 20px;
# }

# .autocomplete-container1 input, .autocomplete-container2 input {
#   width: calc(100% - 43px);
#   outline: none;
  
#   border: 1px solid rgba(0, 0, 0, 0.2);
#   padding: 10px;
#   padding-right: 31px;
#   font-size: 16px;
# }
# /* rgba(0, 0, 0, 0.1) */
# .autocomplete-items1 {
#   position: absolute;

#   border: 1px solid rgba(0, 0, 0, 0.1);
#   box-shadow: 2px rgba(0, 0, 0, 0.1);
#   /* background-color: rgba(48, 50, 129, 0.1); */
#   border-top: none;
#   z-index: 99;
#   /*position the autocomplete items to be the same width as the container:*/
#   top: calc(100% + 50px);
#   left: 0;
#   right: 0;
#   /* border-top: 2px black; */
#   background-color: #fff;
# }

# .autocomplete-items2 {
#   position: absolute;

#   border: 10px solid rgba(0, 0, 0, 0.1);
#   box-shadow: 0px 2px 10px 2px rgba(0, 0, 0, 0.1);
#   border-top: none;
#   z-index: 99;
#   /*position the autocomplete items to be the same width as the container:*/
#   top: calc(100% - 120px);
#   left: 0;
#   right: 0;
  
#   background-color: #fff;
# }

# .autocomplete-items1 div, .autocomplete-items2 div {
#   padding: 10px;
#   cursor: pointer;
#   background-color: #fff;
# }

# .autocomplete-items1 div:hover, .autocomplete-items2 div:hover {
#   /*when hovering an item:*/
#   background-color: rgba(75, 16, 214, 0.5);
#   z-index: 100;
#   color: white;
# }

# .autocomplete-items1 .autocomplete-active, .autocomplete-items2 .autocomplete-active {
#   /*when navigating through the items using the arrow keys:*/
#   background-color: rgba(0, 0, 0, 0.1);
# }

# .clear-button {
#   color: rgba(0, 0, 0, 0.4);
#   cursor: pointer;
  
#   position: absolute;
#   right: 5px;
#   top: 0;

#   height: 100%;
#   display: none;
#   align-items: center;
# }

# .clear-button.visible {
#   display: flex;
# }


# .clear-button:hover {
#   color: rgba(0, 0, 0, 0.6);
# }


#             @media only screen and (max-width: 576px) {
#                 nav.navbar {
#                     display: flex;
#                     flex-direction: column;
#                     width: 100%;
#                 }    
#                 nav.navbar ul {
#                     width: 100%;
#                 }
#             }
            
#         </style>
#         <meta name="viewport" content="width=device-width, initial-scale=1">
#         <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
#         <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
#         <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/fontawesome.min.css" integrity="sha384-jLKHWM3JRmfMU0A5x5AkjWkw/EYfGUAGagvnfryNV3F9VqM98XiIH7VBGVoxVSc7" crossorigin="anonymous">
#         <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.min.js" integrity="sha384-cn7l7gDp0eyniUwwAZgrzD06kc/tftFf19TOAs2zVinnD/C7E91j9yyk5//jjpt/" crossorigin="anonymous"></script>
#         <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
#         <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
#         <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
#         <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
#         <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
#         <link rel="stylesheet" href="http://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
       
#     </head>
#     <body>
#         <nav class="navbar navbar-expand-sm bg-dark w-100">
#             <ul class="navbar-nav d-flex justify-content-between">
#                 <li class="nav-item"><a class="nav-link text-danger" href="#">Home</a></li>
#                 <li class="nav-item"><a class="nav-link text-danger" href="#">About</a></li>
#             </ul>
#         </nav>

#         <!-- <h1>Search the location you want to Travel!</h1> -->
#         {% if location|length==0 %}
        
#           <form class="form mt-4" method='POST' onsubmit="display()">
#             <div>
#                   <label>Source location:</label>
#                   <div class="autocomplete-container1" id="autocomplete-container1"></div>
#               </div>
#               <div>
#                   <label>Destination location:</label>
#                   <!-- <input type="text" placeholder="Enter the Destination location" class='i2' name='destination' required/> -->
#                   <div class="autocomplete-container2" id="autocomplete-container2"></div>
#               </div>
#               <input type="submit" class="submit"  value="Submit" onclick="display();">
             
#           </form>
#         {% endif %}
#          <a href=map  download><button class="GFG">Track Yourself</button></a>
#         <div class="ok" >
#           <li style="display:none;"><div class="clock-loader spinner-border text-warning"></div>Please wait until the Optimized route is generated!</li>
#         </div>  
#           <div class='mt-3 details'>
#             {% if location|length>0 %}
#                 <h3>Source location - {{location[0]}}, Destination location - {{location[1]}}</h3>
#                 <h4>The total Travel Time from {{ location[0].capitalize() }} to {{ location[1].capitalize() }} is approximately {% if travel_time<60 %}
#                 {{ travel_time%60 }} minutes!
#           {% else %}
#               {{ travel_time//60 }} hours {% if travel_time%60!=0 %} {{ travel_time%60 }} minutes! {% endif %}
#           {% endif %} </h4>
#             {% endif %}
#           </div>  
          
#           <div class='container map'>
#             {% if div_placeholder!=None  %}
#                   {% set loader = False %}
#                   <script>
#                     document.querySelector('div.ok').classList.remove("loader");
#                     document.querySelector('.ok li').style.display="none";
#                     document.querySelector('div.ok div').style.display="none";
#                     document.querySelector('div.ok').style.display="none";
#                   </script>
#                   {{ div_placeholder| safe }}   
#             {% endif %}

#           </div>
        
#     <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
#     <script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script>
#     </body>
#     <script>
#         function display(event) {
#           document.querySelector('div.ok').classList.add("loader");
#           document.querySelector('div.ok').style.display="flex";
#           document.querySelector('.loader li').style.display="block";
#           document.querySelector('li .spinner-border').style.display="block";
#           var msg = new SpeechSynthesisUtterance('Building optimized route please hold on. Fetching neighbourhoods please hold on');
#           window.speechSynthesis.speak(msg);
          
        
#       }
#         document.querySelector('input.submit').addEventListener("submit",display);
#         var requestOptions = {
#           method: 'GET',
#         };

        
#             /* 
# 	The addressAutocomplete takes as parameters:
#   - a container element (div)
#   - callback to notify about address selection
#   - geocoder options:
#   	 - placeholder - placeholder text for an input element
#      - type - location type
# */
# function addressAutocomplete(containerElement, callback, options, num) {
#   // create input element
#   var inputElement = document.createElement("input");
#   inputElement.setAttribute("type", "text");
#   inputElement.classList.add("i"+num);
#   if(num==="1"){
#     inputElement.setAttribute("name", "source");
#   }
#   else{
#     inputElement.setAttribute("name", "destination");
#   }
#   inputElement.setAttribute("placeholder", options.placeholder);
#   containerElement.appendChild(inputElement);

#   // add input field clear button
# //   var clearButton = document.createElement("div");
# //   clearButton.classList.add("clear-button");
# //   addIcon(clearButton);
# //   clearButton.addEventListener("click", (e) => {
# //     e.stopPropagation();
# //     inputElement.value = '';
# //     callback(null);
# //     clearButton.classList.remove("visible");
# //     closeDropDownList();
# //   });
# //   containerElement.appendChild(clearButton);

#   /* Current autocomplete items data (GeoJSON.Feature) */
#   var currentItems;

#   /* Active request promise reject function. To be able to cancel the promise when a new request comes */
#   var currentPromiseReject;

#   /* Focused item in the autocomplete list. This variable is used to navigate with buttons */
#   var focusedItemIndex;

#   /* Execute a function when someone writes in the text field: */
#   inputElement.addEventListener("input", function(e) {
#     var currentValue = this.value;

#     /* Close any already open dropdown list */
#     closeDropDownList();

#     // Cancel previous request promise
#     if (currentPromiseReject) {
#       currentPromiseReject({
#         canceled: true
#       });
#     }

#     // if (!currentValue) {
#     //   clearButton.classList.remove("visible");
#     //   return false;
#     // }

#     // // Show clearButton when there is a text
#     // clearButton.classList.add("visible");

#     /* Create a new promise and send geocoding request */
#     var promise = new Promise((resolve, reject) => {
#       currentPromiseReject = reject;

#       var apiKey = "2482a7e6b4504edfaf3df1730626e4f0";
#       var url = `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(currentValue)}&limit=5&apiKey=${apiKey}`;
      
#       if (options.type) {
#       	url += `&type=${options.type}`;
#       }

#       fetch(url)
#         .then(response => {
#           // check if the call was successful
#           if (response.ok) {
#             response.json().then(data => resolve(data));
#           } else {
#             response.json().then(data => reject(data));
#           }
#         });
#     });

#     promise.then((data) => {
#       currentItems = data.features;

#       /*create a DIV element that will contain the items (values):*/
#       var autocompleteItemsElement = document.createElement("div");
#       autocompleteItemsElement.setAttribute("class", "autocomplete-items"+num);
#       containerElement.appendChild(autocompleteItemsElement);

#       /* For each item in the results */
#       data.features.forEach((feature, index) => {
#         /* Create a DIV element for each element: */
#         var itemElement = document.createElement("DIV");
#         /* Set formatted address as item value */
#         itemElement.innerHTML = feature.properties.formatted;

#         /* Set the value for the autocomplete text field and notify: */
#         itemElement.addEventListener("click", function(e) {
#           inputElement.value = currentItems[index].properties.formatted;

#           callback(currentItems[index]);

#           /* Close the list of autocompleted values: */
#           closeDropDownList();
#         });

#         autocompleteItemsElement.appendChild(itemElement);
#       });
#     }, (err) => {
#       if (!err.canceled) {
#         console.log(err);
#       }
#     });
#   });

#   /* Add support for keyboard navigation */
#   inputElement.addEventListener("keydown", function(e) {
#             var autocompleteItemsElement = containerElement.querySelector(".autocomplete-items"+num);
#             if (autocompleteItemsElement) {
#             var itemElements = autocompleteItemsElement.getElementsByTagName("div");
#             if (e.keyCode == 40) {
#                 e.preventDefault();
#                 /*If the arrow DOWN key is pressed, increase the focusedItemIndex variable:*/
#                 focusedItemIndex = focusedItemIndex !== itemElements.length - 1 ? focusedItemIndex + 1 : 0;
#                 /*and and make the current item more visible:*/
#                 setActive(itemElements, focusedItemIndex);
#             } else if (e.keyCode == 38) {
#                 e.preventDefault();

#                 /*If the arrow UP key is pressed, decrease the focusedItemIndex variable:*/
#                 focusedItemIndex = focusedItemIndex !== 0 ? focusedItemIndex - 1 : focusedItemIndex = (itemElements.length - 1);
#                 /*and and make the current item more visible:*/
#                 setActive(itemElements, focusedItemIndex);
#             } else if (e.keyCode == 13) {
#                 /* If the ENTER key is pressed and value as selected, close the list*/
#                 e.preventDefault();
#                 if (focusedItemIndex > -1) {
#                 closeDropDownList();
#                 }
#             }
#             } else {
#             if (e.keyCode == 40) {
#                 /* Open dropdown list again */
#                 var event = document.createEvent('Event');
#                 event.initEvent('input', true, true);
#                 inputElement.dispatchEvent(event);
#             }
#             }
#         });

#         function setActive(items, index) {
#             if (!items || !items.length) return false;

#             for (var i = 0; i < items.length; i++) {
#             items[i].classList.remove("autocomplete-active");
#             }

#             /* Add class "autocomplete-active" to the active element*/
#             items[index].classList.add("autocomplete-active");

#             // Change input value and notify
#             inputElement.value = currentItems[index].properties.formatted;
#             callback(currentItems[index]);
#         }

#         function closeDropDownList() {
#             var autocompleteItemsElement = containerElement.querySelector(".autocomplete-items"+num);
#             if (autocompleteItemsElement) {
#             containerElement.removeChild(autocompleteItemsElement);
#             }

#             focusedItemIndex = -1;
#         }

#         function addIcon(buttonElement) {
#             var svgElement = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
#             svgElement.setAttribute('viewBox', "0 0 24 24");
#             svgElement.setAttribute('height', "24");

#             var iconElement = document.createElementNS("http://www.w3.org/2000/svg", 'path');
#             iconElement.setAttribute("d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z");
#             iconElement.setAttribute('fill', 'currentColor');
#             svgElement.appendChild(iconElement);
#             buttonElement.appendChild(svgElement);
#         }
        
#             /* Close the autocomplete dropdown when the document is clicked. 
#             Skip, when a user clicks on the input field */
#         document.addEventListener("click", function(e) {
#             if (e.target !== inputElement) {
#             closeDropDownList();
#             } else if (!containerElement.querySelector(".autocomplete-items"+num)) {
#             // open dropdown list again
#             var event = document.createEvent('Event');
#             event.initEvent('input', true, true);
#             inputElement.dispatchEvent(event);
#             }
#         });

#         }

#         addressAutocomplete(document.getElementById("autocomplete-container1"), (data) => {
#         console.log("Selected option: ");
#         console.log(data);
#         }, {
#             placeholder: "Enter an Source Address here"
#         }, "1");
#         addressAutocomplete(document.getElementById("autocomplete-container2"), data => {
#             console.log("Selected option: ");
#             console.log(data);
#         }, 
#         {
#             placeholder: "Enter an Destination Address here"
#         }, "2"
#         );
#     </script>
   
# </html>
# '''
# file=open('templates/index.html','w')
# file.write(text)
# file.close()

# text='''
#   <!DOCTYPE hTmL>
# <html>
#   <head>
#     <title>Geolocation</title>
#     <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
#     <style>
#       #map {
#   height: 100%;
# }

# /* Optional: Makes the sample page fill the window. */
# html,
# body {
#   height: 100%;
#   margin: 0;
#   padding: 0;
# }

# .custom-map-control-button {
#   background-color: #fff;
#   border: 0;
#   border-radius: 2px;
#   box-shadow: 0 1px 4px -1px rgba(0, 0, 0, 0.3);
#   margin: 10px;
#   padding: 0 0.5em;
#   font: 400 18px Roboto, Arial, sans-serif;
#   overflow: hidden;
#   height: 40px;
#   cursor: pointer;
# }
# .custom-map-control-button:hover {
#   background: #ebebeb;
# }
#     </style>
#     <!-- jsFiddle will insert css and js -->
#   </head>
#   <body>
#     <div id="map"></div>

#     <!-- Async script executes immediately and must be after any DOM elements used in callback. -->
#    <script
#       src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initMap&v=weekly&channel=2"
#       async
#     ></script>
#     <script>
#       let map, infoWindow;

# function initMap() {
#   map = new google.maps.Map(document.getElementById("map"), {
#     center: { lat: -34.397, lng: 150.644 },
#     zoom: 6,
#   });
#   infoWindow = new google.maps.InfoWindow();

#   const locationButton = document.createElement("button");

#   locationButton.textContent = "Pan to Current Location";
#   locationButton.classList.add("custom-map-control-button");
#   map.controls[google.maps.ControlPosition.TOP_CENTER].push(locationButton);
#   locationButton.addEventListener("click", () => {
#     // Try HTML5 geolocation.
#     if (navigator.geolocation) {
#       navigator.geolocation.getCurrentPosition(
#         (position) => {
#           const pos = {
#             lat: position.coords.latitude,
#             lng: position.coords.longitude,
#           };

#           infoWindow.setPosition(pos);
#           infoWindow.setContent("Location found.");
#           infoWindow.open(map);
#           map.setCenter(pos);
#         },
#         () => {
#           handleLocationError(true, infoWindow, map.getCenter());
#         }
#       );
#     } else {
#       // Browser doesn't support Geolocation
#       handleLocationError(false, infoWindow, map.getCenter());
#     }
#   });
# }

# function handleLocationError(browserHasGeolocation, infoWindow, pos) {
#   infoWindow.setPosition(pos);
#   infoWindow.setContent(
#     browserHasGeolocation
#       ? "Error: The Geolocation service failed."
#       : "Error: Your browser doesn't support geolocation."
#   );
#   infoWindow.open(map);
# }
#     </script>
#   </body>
# </html>
# '''
# file=open('templates/map.html','w')
# file.write(text)
# file.close()



# cd ~/.node_modules
# git clone git://github.com/jimrubenstein/node-mandrill.git



import os, sys
import plotly
import osmnx as ox
import networkx as nx
import plotly.graph_objects as go
import numpy as np
import geopy
import geopandas
import scipy.signal
from pykalman import KalmanFilter
import matplotlib.pyplot as plt
import time
import geopandas as gpd
from geopy.extra.rate_limiter import RateLimiter
import matplotlib.pyplot as plt
from geopy.geocoders import Nominatim
from pprint import pprint
import pandas as pd
import warnings
warnings.filterwarnings('ignore')
from datetime import datetime
from gtts import gTTS 
from IPython.display import Audio
from flask_ngrok import run_with_ngrok
from flask import Flask, render_template, url_for, request, redirect
import folium                    
import folium.plugins as plugins
from folium.plugins import HeatMapWithTime
from folium.plugins import MarkerCluster
from branca.element import Figure
from opencage.geocoder import OpenCageGeocode
from opencage.geocoder import InvalidInputError, RateLimitExceededError, UnknownError


from bs4 import BeautifulSoup
import requests
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3'}
 
 
def weather(city):
    # using openweathermap api
    print(city)
# import required modules
    import requests, json
    
    # Enter your API key here
    api_key = "be2c186e8f4283d29b95c5175dacbddc"
    
    # base_url variable to store url
    base_url = "http://api.openweathermap.org/data/2.5/weather?"
    
    # Give city name
    # city_name = input("Enter city name : ")
    
    # complete_url variable to store
    # complete url address
    complete_url = base_url + "appid=" + api_key + "&q=" + city
    
    # get method of requests module
    # return response object
    response = requests.get(complete_url)
    
    # json method of response object
    # convert json format data into
    # python format data
    x = response.json()
    
    # Now x contains list of nested dictionaries
    # Check the value of "cod" key is equal to
    # "404", means city is found otherwise,
    # city is not found
    if x["cod"] != "404":
    
        # store the value of "main"
        # key in variable y
        y = x["main"]
    
        # store the value corresponding
        # to the "temp" key of y
        current_temperature = y["temp"]
        print(current_temperature)
        # store the value corresponding
        # to the "pressure" key of y
        current_pressure = y["pressure"]
    
        # store the value corresponding
        # to the "humidity" key of y
        current_humidity = y["humidity"]
    
        # store the value of "weather"
        # key in variable z
        z = x["weather"]
    
        # store the value corresponding
        # to the "description" key at
        # the 0th index of z
        weather_description = z[0]["description"]
    
        # print following values
        # print(" Temperature (in kelvin unit) = " +
        #                 str(current_temperature) +
        #       "\n atmospheric pressure (in hPa unit) = " +
        #                 str(current_pressure) +
        #       "\n humidity (in percentage) = " +
        #                 str(current_humidity) +
        #       "\n description = " +
        #                 str(weather_description))
        return current_temperature, weather_description
    
    else:
        print(" City Not Found ")
 
 


# Running the flask App
app=Flask(__name__)
# we need to start ngrok when the app is run
run_with_ngrok(app)
@app.route("/", methods=['GET','POST'])

def index():
  # try:

    locn=[]
    time=0
    div=None
    travel_time=0
    loader=False
    if(request.method=='POST'):
      loader=True
      source_locn=request.form['source']
      dest_locn=request.form['destination']
      locn.append(source_locn)
      locn.append(dest_locn)
      #return redirect(url_for("home", response=[source_locn, dest_locn]))
      print(locn)
      
      #using opencage for converting address into coordinates
      key = '55412a8499cc41ba87bd80b4d84bcab7'
      geocoder = OpenCageGeocode(key)
      query1 = source_locn
      query2 = dest_locn
      source_results = geocoder.geocode(query1)
      dest_results = geocoder.geocode(query2)
      origin_lat,origin_long = source_results[0]['geometry']['lat'], source_results[0]['geometry']['lng']
      dest_lat,dest_long = dest_results[0]['geometry']['lat'], dest_results[0]['geometry']['lng']
      print("Source lat: "+str(origin_lat)+" Source long: "+str(origin_long))
      print("Dest lat: "+str(dest_lat)+" Dest long: "+str(dest_long))


      # locator = geopy.Nominatim(user_agent="2018.rutuja.rajhans@ves.ac.in")
      # location1 = locator.geocode(source_locn,timeout = 50)
      # location2 = locator.geocode(dest_locn,timeout = 50)
      # print("Latitude = {}, Longitude = {}".format(location1.latitude, location1.longitude))
      # print("Latitude = {}, Longitude = {}".format(location2.latitude, location2.longitude))
      # origin_lat = location1.latitude
      # origin_long = location1.longitude
      # dest_lat = location2.latitude
      # dest_long = location2.longitude

      # tts = gTTS("Building route from "+source_locn+" to "+dest_locn) 
      # tts.save('1.wav')
      # sound_file = '1.wav'
      #display(Audio(sound_file, autoplay=True))
     
      #graph view of the map
      G = ox.graph_from_bbox(origin_lat,dest_lat,origin_long,dest_long, network_type='drive')
      G_projected = ox.project_graph(G)
      print("Graph view of map loaded")
      #ox.plot_graph(G_projected)
      G = ox.utils_graph.get_largest_component(G)

      #getting the nearest node from source and destination from the graph by Euclidean algorithm
      origin_point = (origin_lat, origin_long) 
      destination_point = (dest_lat, dest_long)
      origin_node = ox.get_nearest_node(G, origin_point,method='euclidean')
      destination_node = ox.get_nearest_node(G, destination_point,method='euclidean')
      print("Source node: "+str(origin_node))
      print("Destination node: "+str(destination_node))

      #all the nodes between source node and destination node such that the distance is shortest by Dijkstra's algorithm
      print("All the nodes from source to destination: ")
      route = nx.shortest_path(G, origin_node, destination_node, weight='travel_time')
      print(route)

      #getting all the routes from source to destination and storing their coordinates
      routes = ox.k_shortest_paths(G, origin_node, destination_node, k=5, weight='length')
      routes = list(routes)
      #fig, ax = ox.plot_graph_routes(G, list(routes),  route_colors='r', route_linewidth=2, node_size=0)
      lola1 = []
      lola2 = []
      for i in range(len(routes)):
        longi = [] 
        lat = []  
        rr = list(routes[i])
        for j in rr:
          point = G.nodes[j]
          longi.append(point['x'])
          lat.append(point['y'])
        lola1.append(longi)
        lola2.append(lat)
      print("Alternative routes obtained")
    

      #graph view by connecting all the nodes of optimal route
      #fig, ax = ox.plot_graph_route(G, route)
      print("Got the shortest route")

      #getting the latitude & longitude of all the nodes of optimal route for kalman filter estimation
      longi = [] 
      lat = []  
      for i in route:
          point = G.nodes[i]
          longi.append(point['x'])
          lat.append(point['y'])

      #Kalman filter estimation of the coordinates of optimal route between source and destination
      import time
      c2=[]
      for i in route:
          c1 = [] 
          point = G.nodes[i]
          longi = point['x']
          lat = point['y']
          c1.append(longi)
          c1.append(lat)
          c2.append(c1)
      measurements = np.asarray((c2))

      #1st Kalman Filter
      initial_state_mean = [measurements[0, 0],
                          0,
                          measurements[0, 1],
                          0]

      transition_matrix = [[1.0, 1, 0, 0],
                          [0, 1.0, 0, 0],
                          [0, 0, 1.0, 1],
                          [0, 0, 0, 1.0]]

      observation_matrix = [[1, 0, 0, 0],
                          [0, 0, 1, 0]]

      kf1 = KalmanFilter(transition_matrices = transition_matrix,
                      observation_matrices = observation_matrix,
                      initial_state_mean = initial_state_mean)

      kf1 = kf1.em(measurements, n_iter=50)
      (smoothed_state_means, smoothed_state_covariances) = kf1.smooth(measurements)

      plt.figure(figsize=(40,10))

      times = range(measurements.shape[0])
      plt.plot(times, measurements[:, 0], 'bo',
              times, measurements[:, 1], 'ro',
              times, smoothed_state_means[:, 0], 'b--',
              times, smoothed_state_means[:, 2], 'r--',)
              
      #plt.show()

      #2nd Kalman Filter
      kf2 = KalmanFilter(transition_matrices = transition_matrix,
                      observation_matrices = observation_matrix,
                      initial_state_mean = initial_state_mean,
                      observation_covariance = 1000*kf1.observation_covariance,
                      em_vars=['transition_covariance', 'initial_state_covariance'])

      kf2 = kf2.em(measurements, n_iter=50)
      (smoothed_state_means, smoothed_state_covariances)  = kf2.smooth(measurements)

      plt.figure(figsize=(40,10))
      times = range(measurements.shape[0])
      plt.plot(times, measurements[:, 0], 'bo',
              times, measurements[:, 1], 'ro',
              times, smoothed_state_means[:, 0], 'b--',
              times, smoothed_state_means[:, 2], 'r--',)
      #plt.show()

      #3rd Kalman Filter
      time_before = time.time()
      n_real_time = 3

      kf3 = KalmanFilter(transition_matrices = transition_matrix,
                      observation_matrices = observation_matrix,
                      initial_state_mean = initial_state_mean,
                      observation_covariance = 100*kf1.observation_covariance,
                      em_vars=['transition_covariance', 'initial_state_covariance'])

      kf3 = kf3.em(measurements[:-n_real_time, :], n_iter=50)
      (filtered_state_means, filtered_state_covariances) = kf3.filter(measurements[:-n_real_time,:])

      print("Time to build and train kf3: %s seconds" % (time.time() - time_before))

      x_now = filtered_state_means[-1, :]
      P_now = filtered_state_covariances[-1, :]
      x_new = np.zeros((n_real_time, filtered_state_means.shape[1]))
      i = 0

      for measurement in measurements[-n_real_time:, :]:
        time_before = time.time()
        (x_now, P_now) = kf3.filter_update(filtered_state_mean = x_now,
                                            filtered_state_covariance = P_now,
                                            observation = measurement)
        print("Time to update kf3: %s seconds" % (time.time() - time_before))
        x_new[i, :] = x_now
        i = i + 1
      plt.figure(figsize=(40,10))
      old_times = range(measurements.shape[0] - n_real_time)
      new_times = range(measurements.shape[0]-n_real_time, measurements.shape[0])
      plt.plot(times, measurements[:, 0], 'bo',
              times, measurements[:, 1], 'ro',
              old_times, filtered_state_means[:, 0], 'b--',
              old_times, filtered_state_means[:, 2], 'r--',
              new_times, x_new[:, 0], 'b-',
              new_times, x_new[:, 2], 'r-')

      #plt.show()
      
      #measurements after kalman filter of optimal route
      longi = []
      lat = []
      for i in range(len(measurements)):
        longi.append(measurements[i][0])

      for i in range(len(measurements)):
        lat.append(measurements[i][1])
    
      print("Kalman filter estimation done")

      # tts = gTTS("Fetching neighbourhoods.Please hold on!") 
      # tts.save('1.wav')
      # sound_file = '1.wav'
      #display(Audio(sound_file, autoplay=True))

      #reverse geocoding 
      def get_address_by_location(latitude, longitude, language="en"):
        try:
          results = geocoder.reverse_geocode(latitude, longitude , language='de', no_annotations='1')
          if results and len(results):
            required = results[0]['components']
            if required['_type'] in types:
              return required
        except RateLimitExceededError as ex:
          print(ex)
            

      #latitude, longitude and neighbourhoods from source to destination for plotting as markers
      types = ['restaurant','doctors','school','college','hospital','clinic','shop','cinema','building','cafe']
      # df = pd.DataFrame(columns=['Latitude','Longitude','Marker'])
      am_l1,am_l2 = [],[]
      h_l1,h_l2 = [],[]
      edu_l1,edu_l2 = [],[]
      amenity_spots = []
      health_spots = []
      edu_spots = []
      la = lat
      lo = longi
      try:
        for i in range(len(la)):
          address = get_address_by_location(la[i], lo[i])
          if address:
            if address['_type'] == 'restaurant':
              am_l1.append(la[i])
              am_l2.append(lo[i])
              amenity_spots.append(address['restaurant'])
            elif address['_type'] == 'doctors':
              h_l1.append(la[i])
              h_l2.append(lo[i])
              health_spots.append(address['doctors'])
            elif address['_type'] == 'school':
              edu_l1.append(la[i])
              edu_l2.append(lo[i])
              edu_spots.append(address['school'])
            elif address['_type'] == 'college':
              edu_l1.append(la[i])
              edu_l2.append(lo[i])
              edu_spots.append(address['college'])
            elif address['_type'] == 'hospital':
              h_l1.append(la[i])
              h_l2.append(lo[i])
              health_spots.append(address['hospital'])
            elif address['_type'] == 'clinic':
              h_l1.append(la[i])
              h_l2.append(lo[i])
              health_spots.append(address['clinic'])
            elif address['_type'] == 'shop':
              am_l1.append(la[i])
              am_l2.append(lo[i])
              amenity_spots.append(address['shop'])
            elif address['_type'] == 'cinema':
              am_l1.append(la[i])
              am_l2.append(lo[i])
              amenity_spots.append(address['cinema'])
            elif address['_type'] == 'building':
              am_l1.append(la[i])
              am_l2.append(lo[i])
              amenity_spots.append(address['building'])
            elif address['_type'] == 'cafe':
              am_l1.append(la[i])
              am_l2.append(lo[i])
              amenity_spots.append(address['cafe'])

      except KeyError as ke:
        print(ke) 


      print("Fetched neighbourhoods")
          
  
      # #reverse geocoding 
      # def get_address_by_location(latitude, longitude, language="en"):
      #     locator = Nominatim(user_agent="2018.rutuja.rajhans@ves.ac.in",timeout =50)
      #     coordinates = latitude,longitude
      #     location = locator.reverse(coordinates)
      #     return location.raw

      # #latitude, longitude and neighbourhood places from source to destination and storing in dataframe
      # df = pd.DataFrame(columns=['Latitude','Longitude','Marker'])
      # la = lat
      # lo = longi
      # for i in range(len(la)):
      #   address = get_address_by_location(la[i], lo[i])
      #   spot = address['address']
      #   df.loc[i, ['Latitude']] = address['lat']
      #   df.loc[i, ['Longitude']] = address['lon']
      #   try:
      #     mark = spot['neighbourhood']
      #   except:
      #     mark = "NA"
      #   df.loc[i, ['Marker']] = mark
      #   #print(mark)

      # #getting lat,long from dataframe for plotting neighbourhoods on optimal route
      # l1 = []
      # l2 = []
      # spots = []
      # for ind in df.index:
      #   if df['Marker'][ind] != "NA":
      #     l1.append(df['Latitude'][ind])
      #     l2.append(df['Longitude'][ind])
      #     spots.append(df['Marker'][ind])


      #plotting the route on map
      def plot_path(lola2, lola1, lat, long, origin_point, destination_point):

          fig = go.Figure()
          
          #all the routes
          for i in range(0,len(lola1)):
            fig.add_trace(go.Scattermapbox(
                name = "Route",
                mode = "lines",
                lon = lola1[i],
                lat = lola2[i],
                marker = {'size': 10},
                line = dict(width = 4, color = 'blue')))

          #optimal route
          fig.add_trace(go.Scattermapbox(
                name = "Optimal Route",
                mode = "lines",
                lon = longi,
                lat = lat,
                marker = {'size': 10},
                line = dict(width = 6, color = 'black')))

          #neighbourhoods on optimal route
          fig.add_trace(go.Scattermapbox(
                name = "Amenity",
                mode = "markers",
                lon = am_l2,
                lat = am_l1,
                text = amenity_spots,
                textposition="bottom center",
                marker = {'size': 10, 'color':"papayawhip"}))
          
          fig.add_trace(go.Scattermapbox(
                name = "Health",
                mode = "markers",
                lon = h_l2,
                lat = h_l1,
                text = health_spots,
                textposition="bottom center",
                marker = {'size': 15, 'color':"green"}))
          
          fig.add_trace(go.Scattermapbox(
                name = "Education",
                mode = "markers",
                lon = edu_l2,
                lat = edu_l1,
                text = edu_spots,
                textposition="bottom center",
                marker = {'size': 15, 'color':"violet"}))

          #source marker
          try:
             source_info=weather(source_locn)
             fig.add_trace(go.Scattermapbox(
                  name = "Source",
                  mode = "markers",
                  text = source_locn.capitalize()+ "\nTemperature: "+str(round(float(source_info[0])- 273.15,2))+"°C"+ "\nWeather Description: "+source_info[1].title(),
                  lon = [origin_point[1]],
                  lat = [origin_point[0]],
                  marker = {'size': 20, 'color':"red"}))
          except:
                fig.add_trace(go.Scattermapbox(
                  name = "Source",
                  mode = "markers",
                  text = source_locn.capitalize(),
                  lon = [origin_point[1]],
                  lat = [origin_point[0]],
                  marker = {'size': 20, 'color':"red"}))
          #dest marker  
          try: 
              dest_info=weather(dest_locn)
              fig.add_trace(go.Scattermapbox(
                  name = "Destination",
                  mode = "markers",
                  text =  dest_locn.capitalize()+ "\nTemperature: "+str(round(float(dest_info[0])- 273.15,2))+"°C"+ "\nWeather Description: "+dest_info[1].title(),
                  lon = [destination_point[1]],
                  lat = [destination_point[0]],
                  marker = {'size': 20, 'color':'red'}))
          except:
              fig.add_trace(go.Scattermapbox(
                 name = "Destination",
                 mode = "markers",
                 text =  dest_locn.capitalize(),
                 lon = [destination_point[1]],
                 lat = [destination_point[0]],
                 marker = {'size': 20, 'color':'red'}))
              
          #centre of map
          lat_center = origin_point[0]
          long_center = origin_point[1]
          fig.update_layout(mapbox_style="stamen-terrain",
              mapbox_center_lat = 30, mapbox_center_lon=-80)
          fig.update_layout(margin={"r":0,"t":0,"l":0,"b":0},
                            mapbox = {
                                'center': {'lat': lat_center, 
                                'lon': long_center},
                                'zoom': 12})
          

          #fig.show()
          return fig
        
      fig=plot_path(lola2, lola1, lat, longi, origin_point, destination_point)

      #see the travel time for the whole optimal route
      travel_time = nx.shortest_path_length(G, origin_node, destination_node, weight='travel_time')
      print("Total travel time : "+str(travel_time)+" minutes approximately")
      
      # if travel_time<=60:
      #   tts = gTTS("Travel time is"+str(travel_time)+"minutes approximately") 
          
      # elif travel_time>60:
      #   tts = gTTS("Travel time is"+str(travel_time//60)+"hours"+str(travel_time%60)+"minutes approximately") 

      # tts.save('1.wav')
      # sound_file = '1.wav'
      #display(Audio(sound_file, autoplay=True))


      div = fig.to_html(full_html=False)
    
      
  # except:
  #     print("Some error occurred")
  #     tts = gTTS("Some error occurred") 
  #     tts.save('1.wav')
  #     sound_file = '1.wav'
  #     #display(Audio(sound_file, autoplay=True))

    return render_template('index.html', location=locn, div_placeholder=div, travel_time=travel_time, loader=loader )
@app.route('/map')
def map():
  return render_template('map.html')
  
if __name__ == '__main__':       
  app.run(debug=False)



from google.colab.output import eval_js
eval_js("google.colab.kernel.proxyPort(5000)")

